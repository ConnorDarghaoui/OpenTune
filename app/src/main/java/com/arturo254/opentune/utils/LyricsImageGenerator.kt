package com.arturo254.opentune.utils

import android.content.ContentValues
import android.content.Context
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.LinearGradient
import android.graphics.Paint
import android.graphics.Path
import android.graphics.PorterDuff
import android.graphics.PorterDuffColorFilter
import android.graphics.Rect
import android.graphics.RectF
import android.graphics.Shader
import android.graphics.Typeface
import android.net.Uri
import android.os.Build
import android.os.Environment
import android.provider.MediaStore
import android.text.Layout
import android.text.StaticLayout
import android.text.TextPaint
import androidx.annotation.RequiresApi
import androidx.core.content.FileProvider
import androidx.core.graphics.createBitmap
import androidx.core.graphics.drawable.toBitmap
import androidx.core.graphics.withTranslation
import coil.ImageLoader
import coil.request.ImageRequest
import com.arturo254.opentune.R
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream

object ComposeToImage {

    fun saveBitmapAsFile(context: Context, bitmap: Bitmap, fileName: String): Uri {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            saveToMediaStore(context, bitmap, fileName)
        } else {
            saveToCache(context, bitmap, fileName)
        }
    }

    @RequiresApi(Build.VERSION_CODES.Q)
    private fun saveToMediaStore(context: Context, bitmap: Bitmap, fileName: String): Uri {
        val contentValues = buildContentValues(fileName)
        val uri = context.contentResolver.insert(
            MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
            contentValues
        ) ?: throw IllegalStateException("Failed to create new MediaStore record")

        context.contentResolver.openOutputStream(uri)?.use { outputStream ->
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream)
        }
        return uri
    }

    private fun buildContentValues(fileName: String): ContentValues = ContentValues().apply {
        put(MediaStore.MediaColumns.DISPLAY_NAME, "$fileName.png")
        put(MediaStore.MediaColumns.MIME_TYPE, "image/png")
        put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_PICTURES + "/OpenTune")
    }

    private fun saveToCache(context: Context, bitmap: Bitmap, fileName: String): Uri {
        val cachePath = File(context.cacheDir, "images")
        cachePath.mkdirs()
        val imageFile = File(cachePath, "$fileName.png")

        FileOutputStream(imageFile).use { outputStream ->
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream)
        }

        return FileProvider.getUriForFile(
            context,
            "${context.packageName}.FileProvider",
            imageFile
        )
    }

    @RequiresApi(Build.VERSION_CODES.M)
    suspend fun createLyricsImage(
        context: Context,
        coverArtUrl: String?,
        songTitle: String,
        artistName: String,
        lyrics: String,
        width: Int,
        height: Int,
        backgroundColor: Int? = null,
        textColor: Int? = null,
        secondaryTextColor: Int? = null,
        showCoverArt: Boolean = true,
        showLogo: Boolean = true,
        backgroundStyle: String = "SOLID",
        gradientColors: IntArray? = null,
        fontStyle: String = "EXTRA_BOLD",
        logoPosition: String = "BOTTOM_LEFT",
        cornerRadius: Float = 28f,
        patternOpacity: Float = 0.03f
    ): Bitmap = withContext(Dispatchers.Default) {
        // Usar tamaño cuadrado de alta calidad (1080x1080 como Instagram/Spotify)
        val imageSize = 1080
        val bitmap = createBitmap(imageSize, imageSize)
        val canvas = Canvas(bitmap)

        val bgColor = backgroundColor ?: 0xFF0A0A0A.toInt()
        val mainTextColor = textColor ?: 0xFFFFFFFF.toInt()
        val secTextColor = secondaryTextColor ?: 0xFFB0B0B0.toInt()

        // Padding y tamaños proporcionales
        val outerPadding = imageSize * 0.084f // 32dp en 380dp = 0.084
        val thumbnailSize = imageSize * 0.21f // 80dp en 380dp = 0.21
        val logoSize = imageSize * 0.073f // ~28dp
        val cornerRadiusPx = (cornerRadius / 28f) * (imageSize * 0.073f) // Proporcional

        // 1. Fondo con borde redondeado
        val bgRect = RectF(0f, 0f, imageSize.toFloat(), imageSize.toFloat())
        renderBackground(
            canvas,
            bgRect,
            cornerRadiusPx,
            bgColor,
            mainTextColor,
            backgroundStyle,
            gradientColors,
            patternOpacity,
            imageSize
        )

        // 2. Carátula y metadata (si está habilitado)
        if (showCoverArt) {
            val coverArt = loadCoverArtwork(context, coverArtUrl)
            renderCoverArtHighRes(
                canvas,
                coverArt,
                outerPadding,
                thumbnailSize,
                mainTextColor
            )
            renderSongMetadataHighRes(
                canvas,
                songTitle,
                artistName,
                outerPadding,
                thumbnailSize,
                imageSize,
                mainTextColor,
                secTextColor,
                fontStyle
            )
        }

        // 3. Letras centradas
        renderLyricsHighRes(
            canvas,
            lyrics,
            imageSize,
            outerPadding,
            thumbnailSize,
            mainTextColor,
            bgColor,
            fontStyle,
            showCoverArt
        )

        // 4. Logo de la app
        if (showLogo) {
            renderAppLogoHighRes(
                context,
                canvas,
                imageSize,
                outerPadding,
                logoSize,
                secTextColor,
                logoPosition
            )
        }

        bitmap
    }

    private fun renderBackground(
        canvas: Canvas,
        rect: RectF,
        cornerRadius: Float,
        backgroundColor: Int,
        textColor: Int,
        backgroundStyle: String,
        gradientColors: IntArray?,
        patternOpacity: Float,
        imageSize: Int
    ) {
        when (backgroundStyle) {
            "SOLID" -> {
                val paint = Paint().apply {
                    color = backgroundColor
                    isAntiAlias = true
                }
                canvas.drawRoundRect(rect, cornerRadius, cornerRadius, paint)
            }

            "GRADIENT" -> {
                val colors = gradientColors ?: intArrayOf(backgroundColor, backgroundColor)
                val paint = Paint().apply {
                    isAntiAlias = true
                    shader = LinearGradient(
                        0f, 0f,
                        rect.width(), rect.height(),
                        colors,
                        null,
                        Shader.TileMode.CLAMP
                    )
                }
                canvas.drawRoundRect(rect, cornerRadius, cornerRadius, paint)
            }

            "PATTERN" -> {
                // Primero el fondo sólido
                val paint = Paint().apply {
                    color = backgroundColor
                    isAntiAlias = true
                }
                canvas.drawRoundRect(rect, cornerRadius, cornerRadius, paint)

                // Clip para que el patrón respete las esquinas redondeadas
                val clipPath = Path().apply {
                    addRoundRect(rect, cornerRadius, cornerRadius, Path.Direction.CW)
                }
                canvas.save()
                canvas.clipPath(clipPath)

                // Luego el patrón
                val patternPaint = Paint().apply {
                    color = textColor
                    alpha = (patternOpacity * 255).toInt()
                    isAntiAlias = true
                }
                val pattern = imageSize * 0.037f // 40dp proporcional
                val radius = imageSize * 0.00185f // 2dp proporcional
                var x = 0f
                while (x <= rect.width()) {
                    var y = 0f
                    while (y <= rect.height()) {
                        canvas.drawCircle(x, y, radius, patternPaint)
                        y += pattern
                    }
                    x += pattern
                }
                canvas.restore()
            }
        }
    }

    private suspend fun loadCoverArtwork(context: Context, coverArtUrl: String?): Bitmap? {
        if (coverArtUrl.isNullOrEmpty()) return null
        return try {
            val imageLoader = ImageLoader(context)
            val request = ImageRequest.Builder(context)
                .data(coverArtUrl)
                .size(800, 800) // Alta resolución
                .allowHardware(false)
                .build()
            val result = imageLoader.execute(request)
            result.drawable?.toBitmap(800, 800, Bitmap.Config.ARGB_8888)
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    private fun renderCoverArtHighRes(
        canvas: Canvas,
        coverArt: Bitmap?,
        padding: Float,
        size: Float,
        textColor: Int
    ) {
        coverArt?.let { artwork ->
            val rect = RectF(padding, padding, padding + size, padding + size)
            val cornerRadius = size * 0.25f // 20dp en 80dp = 0.25

            // Fondo
            val bgPaint = Paint().apply {
                color = textColor
                alpha = 25 // 0.1 * 255
                isAntiAlias = true
            }
            canvas.drawRoundRect(rect, cornerRadius, cornerRadius, bgPaint)

            // Imagen con clip redondeado
            val paint = Paint().apply {
                isAntiAlias = true
                isFilterBitmap = true
            }
            val clipPath = Path().apply {
                addRoundRect(rect, cornerRadius, cornerRadius, Path.Direction.CW)
            }
            canvas.save()
            canvas.clipPath(clipPath)
            canvas.drawBitmap(artwork, null, rect, paint)
            canvas.restore()

            // Borde
            val borderPaint = Paint().apply {
                color = textColor
                alpha = 51 // 0.2 * 255
                style = Paint.Style.STROKE
                strokeWidth = 2f
                isAntiAlias = true
            }
            canvas.drawRoundRect(rect, cornerRadius, cornerRadius, borderPaint)
        }
    }

    private fun renderSongMetadataHighRes(
        canvas: Canvas,
        songTitle: String,
        artistName: String,
        padding: Float,
        thumbnailSize: Float,
        imageSize: Int,
        mainTextColor: Int,
        secondaryTextColor: Int,
        fontStyle: String
    ) {
        val spacing = imageSize * 0.042f // 16dp
        val startX = padding + thumbnailSize + spacing
        val maxWidth = (imageSize - startX - padding).toInt()

        val titleTypeface = when (fontStyle) {
            "REGULAR" -> Typeface.create(Typeface.DEFAULT, Typeface.BOLD)
            "BOLD" -> Typeface.create("sans-serif-black", Typeface.NORMAL)
            "EXTRA_BOLD" -> Typeface.create("sans-serif-black", Typeface.BOLD)
            else -> Typeface.create("sans-serif-black", Typeface.BOLD)
        }

        // Título - 20sp en 380dp = 0.0526
        val titlePaint = TextPaint().apply {
            color = mainTextColor
            textSize = imageSize * 0.0526f
            typeface = titleTypeface
            isAntiAlias = true
            letterSpacing = -0.025f
        }

        // Artista - 16sp en 380dp = 0.042
        val artistPaint = TextPaint().apply {
            color = secondaryTextColor
            textSize = imageSize * 0.042f
            typeface = Typeface.create("sans-serif-medium", Typeface.NORMAL)
            isAntiAlias = true
            letterSpacing = 0.0125f
        }

        val titleLayout = StaticLayout.Builder.obtain(
            songTitle, 0, songTitle.length, titlePaint, maxWidth
        )
            .setAlignment(Layout.Alignment.ALIGN_NORMAL)
            .setMaxLines(2)
            .setLineSpacing(0f, 1.2f)
            .setEllipsize(android.text.TextUtils.TruncateAt.END)
            .build()

        val artistLayout = StaticLayout.Builder.obtain(
            artistName, 0, artistName.length, artistPaint, maxWidth
        )
            .setAlignment(Layout.Alignment.ALIGN_NORMAL)
            .setMaxLines(1)
            .setEllipsize(android.text.TextUtils.TruncateAt.END)
            .build()

        // Centrar verticalmente en el thumbnail
        val centerY = padding + thumbnailSize / 2f
        val textBlockHeight =
            titleLayout.height + artistLayout.height + (imageSize * 0.0105f) // 4dp
        val startY = centerY - textBlockHeight / 2f

        canvas.withTranslation(startX, startY) {
            titleLayout.draw(this)
            translate(0f, titleLayout.height + imageSize * 0.0105f)
            artistLayout.draw(this)
        }
    }

    private fun renderLyricsHighRes(
        canvas: Canvas,
        lyrics: String,
        imageSize: Int,
        padding: Float,
        thumbnailSize: Float,
        textColor: Int,
        backgroundColor: Int,
        fontStyle: String,
        showCoverArt: Boolean
    ) {
        val lyricsTypeface = when (fontStyle) {
            "REGULAR" -> Typeface.create(Typeface.DEFAULT, Typeface.BOLD)
            "BOLD" -> Typeface.create("sans-serif-black", Typeface.NORMAL)
            "EXTRA_BOLD" -> Typeface.create("sans-serif-black", Typeface.BOLD)
            else -> Typeface.create("sans-serif-black", Typeface.BOLD)
        }

        val maxWidth = (imageSize * 0.85f).toInt()
        val headerHeight =
            if (showCoverArt) padding + thumbnailSize + (imageSize * 0.084f) else padding
        val footerHeight = imageSize * 0.148f // ~80dp para el logo
        val maxHeight = imageSize - headerHeight - footerHeight

        // Tamaño inicial proporcional
        var textSize = imageSize * 0.055f // Ajustar según diseño
        val minTextSize = imageSize * 0.037f

        val paint = TextPaint().apply {
            color = textColor
            typeface = lyricsTypeface
            isAntiAlias = true
            letterSpacing = 0.015f
        }

        var layout: StaticLayout
        do {
            paint.textSize = textSize
            layout = StaticLayout.Builder.obtain(lyrics, 0, lyrics.length, paint, maxWidth)
                .setAlignment(Layout.Alignment.ALIGN_CENTER)
                .setIncludePad(false)
                .setLineSpacing(0f, 1.3f)
                .build()
            if (layout.height <= maxHeight) break
            textSize -= imageSize * 0.0028f
        } while (textSize > minTextSize)

        if (textSize < minTextSize) {
            paint.textSize = minTextSize
            layout = StaticLayout.Builder.obtain(lyrics, 0, lyrics.length, paint, maxWidth)
                .setAlignment(Layout.Alignment.ALIGN_CENTER)
                .setIncludePad(false)
                .setLineSpacing(0f, 1.3f)
                .build()
        }

        // Sombra sutil
        paint.setShadowLayer(
            imageSize * 0.0037f,
            imageSize * 0.00185f,
            imageSize * 0.00185f,
            backgroundColor
        )

        val posX = (imageSize - layout.width) / 2f
        val availableHeight = imageSize - headerHeight - footerHeight
        val posY = headerHeight + (availableHeight - layout.height) / 2f

        canvas.withTranslation(posX, posY) {
            layout.draw(this)
        }
    }

    private fun renderAppLogoHighRes(
        context: Context,
        canvas: Canvas,
        imageSize: Int,
        padding: Float,
        logoSize: Float,
        textColor: Int,
        logoPosition: String
    ) {
        val logoBitmap = getBitmapFromVectorDrawable(
            context, R.drawable.opentune, logoSize.toInt(), logoSize.toInt()
        ) ?: return

        // Posición del logo
        val (logoX, logoY) = when (logoPosition) {
            "BOTTOM_LEFT" -> Pair(padding, imageSize - padding - logoSize)
            "BOTTOM_RIGHT" -> Pair(
                imageSize - padding - logoSize - (imageSize * 0.185f),
                imageSize - padding - logoSize
            )

            "TOP_LEFT" -> Pair(padding, padding)
            "TOP_RIGHT" -> Pair(imageSize - padding - logoSize - (imageSize * 0.185f), padding)
            else -> Pair(padding, imageSize - padding - logoSize)
        }

        // Fondo circular del logo
        val circleRadius = logoSize * 1.29f // 36dp para 28dp de logo
        val circleCenterX = logoX + logoSize / 2f
        val circleCenterY = logoY + logoSize / 2f

        val circleBgPaint = Paint().apply {
            color = textColor
            alpha = 38 // 0.15 * 255
            isAntiAlias = true
        }
        canvas.drawCircle(circleCenterX, circleCenterY, circleRadius / 2f, circleBgPaint)

        val circleBorderPaint = Paint().apply {
            color = textColor
            alpha = 76 // 0.3 * 255
            style = Paint.Style.STROKE
            strokeWidth = imageSize * 0.00093f // 1dp
            isAntiAlias = true
        }
        canvas.drawCircle(circleCenterX, circleCenterY, circleRadius / 2f, circleBorderPaint)

        // Logo con tinte
        val paint = Paint().apply {
            colorFilter = PorterDuffColorFilter(textColor, PorterDuff.Mode.SRC_IN)
            isAntiAlias = true
        }

        // Centrar el logo en el círculo
        val logoOffsetX = logoX + (circleRadius - logoSize) / 2f
        val logoOffsetY = logoY + (circleRadius - logoSize) / 2f
        canvas.drawBitmap(logoBitmap, logoOffsetX, logoOffsetY, paint)

        // Texto del nombre de la app
        val appName = context.getString(R.string.app_name)
        val textPaint = TextPaint().apply {
            color = textColor
            textSize = imageSize * 0.0395f // 15sp
            typeface = Typeface.create("sans-serif-medium", Typeface.NORMAL)
            isAntiAlias = true
            letterSpacing = 0.02f
        }

        val textBounds = Rect()
        textPaint.getTextBounds(appName, 0, appName.length, textBounds)
        val textHeight = textBounds.height()

        val textX = logoX + circleRadius + (imageSize * 0.0315f) // 12dp spacing
        val textY = logoY + logoSize / 2f + textHeight / 2f - (imageSize * 0.0105f) // -4dp ajuste

        canvas.drawText(appName, textX, textY, textPaint)
    }

    private fun getBitmapFromVectorDrawable(
        context: Context,
        drawableId: Int,
        width: Int,
        height: Int
    ): Bitmap? {
        val drawable = context.getDrawable(drawableId) ?: return null
        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(bitmap)
        drawable.setBounds(0, 0, width, height)
        drawable.draw(canvas)
        return bitmap
    }
}